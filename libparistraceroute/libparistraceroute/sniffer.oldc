#include "sniffer.h"
#include "network.h"

#include <unistd.h>
#include <fcntl.h>
#include <errno.h>
#include <string.h>
#include <stdlib.h>


// =======================
// == List of functions ==
// =======================
struct set_t* sniffer_pcap_get_dev (struct set_t* ipset);
char*         sniffer_pcap_get_filter (u_int16_t* protocols);
int          sniffer_thread_init (struct sniffer_t* handle, char* devname, u_int16_t* protocols, u_int32_t* ipssrc);
void          sniffer_thread_close (struct sniffer_thread_t* handle);
void*         sniffer_thread_run (void* params);

// ============================
// == Some useful functions ==
// ============================
/*! \brief Return the device name wich has the IP address 'src'.
 *
 *  Search the first device that has 'src' as IP address and then return it. If
 *  no such device exist, return NULL. It is up to the caller to free the string
 *  returned.
 *
 *  @param src IPv4 address in network byte order
 *  @return A set of device name
 */
int pcap_get_device(char* IP_src, int* nb_dev, char** devices) {//TODO : verif char**
	//struct set_t* devset = set_init();
        char errbuf[PCAP_ERRBUF_SIZE];
	*nb_dev=0;
	char ** dev = NULL;
        // Get all interfaces
        pcap_if_t *ifs, *i;
        int res = pcap_findalldevs(&ifs, errbuf);
        if (res == -1) {
                fprintf(stderr,"Cannot get all interfaces: %s\n", (char*)errbuf);
                return -1;
        }

        // Check wich interface correspond to the right source address: 'src'
        i = ifs;
        while (i != NULL) {
		#ifdef DEBUG
                fprintf(stdout,"dev[%s]: found\n", i->name); 
		#endif
                pcap_addr_t *addrs = i->addresses;
                while (addrs != NULL) {
                        sockaddr_u* addr;
                        addr = (struct sockaddr*)addrs->addr;
                        if (addr->sa_family == AF_INET) {
				socaddr_in* addr4 = (sockaddr_in*) addr;
                                struct in_addr ip4 = addr->sin_addr;
				#ifdef DEBUG
				fprintf(stdout,"dev[%s]: %s\n", i->name, inet_ntoa(ip4));
				#endif
                                if (strcmp(IP_src,inet_ntoa(ip4)==0) {//compare the strings
					#ifdef DEBUG
					fprintf(stdout,"dev[%s]: selected\n", i->name);
					#endif
					*nb_dev=*nb_dev+1;
					realloc(dev,*nb_dev*sizeof(char*));
					*dev[*nb_dev-1]=malloc(strlen(i->name)*sizeof(char));
					*dev[*nb_dev-1]=i->name;
					//set_add(devset, i->name, strlen(i->name)+1);
				    break;
				}
				else {
					#ifdef DEBUG
					fprintf(stdout,"dev[%s]: not selected\n", i->name);
					#endif
				}
                        }
			if(addr->sa_family == AF_INET6){
				//TODO
			}

                        addrs = addrs->next;
                }
                i = i->next;
        }
        pcap_freealldevs(ifs);

	return 1;
}


struct set_t* sniffer_pcap_get_all_ip4_dev () {
	struct set_t* devset = set_init();
        char errbuf[PCAP_ERRBUF_SIZE];

        // Get all interfaces
        pcap_if_t *ifs, *i;
        int res = pcap_findalldevs(&ifs, errbuf);
        if (res == -1) {
                fatal("Cannot get all interfaces: %s", (char*)errbuf);
                return NULL;
        }

	if (ifs == NULL) error("No device found");

        // Check wich interface have an IP4 address
        i = ifs;
        while (i != NULL) {
                debug("dev[%s]: found", i->name); 
                pcap_addr_t *addrs = i->addresses;
                while (addrs != NULL) {
                        struct sockaddr_in *addr;
                        addr = (struct sockaddr_in*)addrs->addr;
                        if (addr->sin_family == AF_INET) {
				debug("dev[%s]: selected", i->name);
				set_add(devset, i->name, strlen(i->name)+1);
				break;
			}
                        addrs = addrs->next;
                }
                i = i->next;
        }
        pcap_freealldevs(ifs);

	return devset;
}

/*! \brief Construct a pcap filter expression from an array of protocols.
 *
 *  This function takes a null-terminated array of protocol numbers and
 *  transform it into a pcap filter expression. For example the array
 *  [1, 17, 6, 0] returns "icmp and udp and tcp". It is up to the caller to
 *  free the string returned.
 *
 *  @param protocols Null-terminated array of protocol number.
 *  @return Pcap filter expression.
 */
char* sniffer_pcap_get_filter (char** protocols, int nb_proto) {
        // Get the filter expression
        char expr[128];
        expr[0] = '\0';

        if (protocols != NULL||*protocols!=NULL) {
	        int first = 1;
		int i = 0;
	        while (i < nb_proto) {
        	        // Abort if there is no enough place in the buffer
	                if (strlen(expr) + 16 >= 128) return NULL;
	                char* proto_name = protocols[i];
	                if (proto_name == NULL){
				#ifdef DEBUG
				fprintf(stderr,"size or array incorrect : no %i th protocol specified\n",i);
				#endif
				return NULL;
			}
	                if (first==0) strcat(expr, " or ");
	                strncat(expr, proto_name, 12);
	                //free(proto_name);
			first = 0;
	                i++;
	        }
	}

        info("filter expr: %s", expr);
        return strdup(expr);
}

// ==============================
// == Manage a list of threads ==
// ==============================
/*! \brief Create a libpcap handler.
 * 
 *  Create a libpcap handler. Blablabla.
 * 
 *  @param listen A libpcap handler.
 *  @param proto  Protocol to listen (see /etc/protocols).
 *  @param port   Port to listen (0 for ICMP).
 */
int sniffer_init (struct sniffer_t* handle, uint16* protocols, uint32* ipssrc) {
	// Iterator
	int i;

	// Create the queue that will contains informations on each thread
	handle->threads = queue_init();

	// Get the set of devices to listen onto
	struct set_t* devset;
	if (ipssrc == NULL) {
		// Use all devices
		devset = sniffer_pcap_get_all_ip4_dev();
	} else {
		// Use devices that matches the IP sources addresses
		struct set_t* ipset = set_init();
		i = 0;
		while (ipssrc[i] != 0) { 
			set_add(ipset, &(ipssrc[i]), sizeof(uint32));
			i++;
		}

        	// Get device names to sniff packet incoming
		devset = sniffer_pcap_get_dev(ipset);
		set_close(ipset);
	}

	// Cannot initialize if no device found
	if (set_isempty(devset)) {
		error("No suitable device found to listen onto");
		sniffer_close(handle);
		return 0;
	}

	// Prepare a thread for each device
	for (i = 0; i < set_length(devset); i++) {
		char* devname;
		int  len;
		set_get(devset, i, (void**)(&devname), &len);
		sniffer_thread_init(handle, devname, protocols, ipssrc);
		info("thread[%s]: prepared", devname);
	}

	// Close sets
	set_close(devset);

	return 1;
}

/** \brief Stop the thread if necessary and close the libpcap handler.
 *
 *  @param listen A libpcap handler.
 */
void sniffer_close (struct sniffer_t* handle) {
	// Iterator
	int i;

	// Destroy the threads structure
	struct sniffer_thread_t* thread;
	for (i = 0; i < queue_length(handle->threads); i++) {
		thread=(struct sniffer_thread_t*)queue_get(handle->threads, i);
		info("thread[%s]: destroyed", thread->devname);
		sniffer_thread_close(thread);
	}

	// Free the main structure
	queue_close(handle->threads);
}

/** \brief Start to capture datagrams.
 *
 *  Start a thread that will capture all packets from the libpcap handler
 *  defined in <i>listen</i>.
 * 
 *  @param listen   A libpcap handler.
 *  @param callback Callback function that will received all datagrams captured.
 */
void sniffer_start (struct sniffer_t* handle, void (*callback)(struct libnet_packet_t*, void*), void* params) {
	// Iterator
	int i;

	// Start all threads
	struct sniffer_thread_t* lthread;
	for (i = 0; i < queue_length(handle->threads); i++) {
		lthread = queue_get(handle->threads, i);
		lthread->callback       = callback;
		lthread->params         = params;
		lthread->thread_running = true;
		info("thread[%s]: start", lthread->devname);
		pthread_create(&lthread->thread, NULL, 
				(void*)&sniffer_thread_run, lthread);
		lthread->thread_created = true;
	}
}

/** \brief Stop to capture datagrams.
 * 
 *  Stop the thread used to capture datagrams.
 *
 *  @param listen A libpcap handler.
 */
void sniffer_stop (struct sniffer_t* handle) {
	// Iterator
	int i;
	struct sniffer_thread_t* lthread;

	// Loop through all threads
	// ... and ask a stop...
	for (i = 0; i < queue_length(handle->threads); i++) {
		lthread = queue_get(handle->threads, i);
		pthread_mutex_lock(&(lthread->lock));
		if (lthread->thread_running) {
			info("thread[%s]: stop asked", lthread->devname);
			lthread->thread_running = false;
		}
		pthread_mutex_unlock(&(lthread->lock));
	}

	// ... then wait the stop...
	for (i = 0; i < queue_length(handle->threads); i++) {
		lthread = queue_get(handle->threads, i);
		if (lthread->thread_created) {
			info("thread[%s]: join thread", lthread->devname);
			pthread_join(lthread->thread, NULL);
		}
		info("thread[%s]: stop effective", lthread->devname);
	}
}

// ============================
// == Manage a single thread ==
// ============================
int sniffer_thread_init (struct sniffer_t* handle, char* devname, uint16* protocols, uint32* ipssrc) {
	// Our netmask
	bpf_u_int32 mask;
	// Our IP
	bpf_u_int32 net;
	// Error string
	char errbuf[PCAP_ERRBUF_SIZE];
	// The compiled filter
	struct bpf_program fp;

	// Create a empty sniffer thread
	struct sniffer_thread_t* lthread 
		= malloc(sizeof(struct sniffer_thread_t));
	memset(lthread, 0, sizeof(struct sniffer_thread_t));

	// TODO: we should be able to disable this function
        if (pcap_lookupnet(devname, &net, &mask, errbuf) == -1) {
                error("Can't get netmask for device %s", devname);
		return 0;
	}

        // Open the device
        lthread->pcap_hd = pcap_open_live(devname, BUFSIZ, 0, 10, errbuf);
        if (lthread->pcap_hd == NULL) {
                error("Couldn't open device %s: %s\n", devname, errbuf);
		sniffer_thread_close(lthread);
		return 0;
	}

        // Get the length of the datalink layer (in bytes)
        int datalink_type   = pcap_datalink(lthread->pcap_hd);
        int datalink_length = 0;
        switch (datalink_type) {
                case DLT_NULL:          // BSD loopback
                case DLT_LOOP:          // OpenBSD loopback
                        datalink_length = 4;
                        break;
                case DLT_EN10MB:        // Ethernet
                        datalink_length = 14; //??
                        break;
                case DLT_RAW:           // Direct IP
                        datalink_length = 0;
                        break;
                case DLT_IEEE802_11:    // IEEE802.11 wireless aln
                case DLT_PPP:           // PPP
                case DLT_IEEE802_11_RADIO: // ??
                default:                // Old stuff
                        error("Unsupporterd link layer");
			sniffer_thread_close(lthread);
			return 0;
        }
        lthread->datalink_length = datalink_length;

#ifdef BSDSOCKET
	// Get the pcap file descriptor
	lthread->pcap_fd = pcap_get_selectable_fd(lthread->pcap_hd);
	if (lthread->pcap_fd == -1) {
		error("Cannot get the pcap file descriptor");
		sniffer_thread_close(lthread);
		return 0;
	}
#endif

#ifdef WINSOCKET
	// Get a Win32::Event structure
	lthread->w32event = pcap_getevent(lthread->pcap_hd);
	//TODO: what is returned if 'pcap_getevent' fails?
#endif

	// Get, compile and apply the filter
        char* filter_expr = sniffer_pcap_get_filter(protocols);
        if (filter_expr == NULL) {
                fatal("Cannot construct the pcap filter");
		sniffer_thread_close(lthread);
		return 0;
	}

        if (pcap_compile(lthread->pcap_hd, &fp, filter_expr, 0, net) == -1) {
                fatal("Couldn't parse filter %s: %s",
                                filter_expr, pcap_geterr(lthread->pcap_hd));
		sniffer_thread_close(lthread); free(filter_expr);
		return 0;
	}

        if (pcap_setfilter(lthread->pcap_hd, &fp) == -1) {
                fatal("Couldn't apply filter %s: %s",
                                filter_expr, pcap_geterr(lthread->pcap_hd));
		sniffer_thread_close(lthread); free(filter_expr);
		return 0;
	}

	free(filter_expr);

	// Create a mutex
	int res = pthread_mutex_init(&(lthread->lock), NULL);
	if (res != 0) {
		fatal("Create mutex failed");
		sniffer_thread_close(lthread);
		return 0;
	}
	
	// Copy the device name
	lthread->devname = strdup(devname);

	// The thread is not running yet
	lthread->thread_running = 0;
	lthread->thread_created = 0;

	// Add this thread to the sniffer handler
	lifo_push(handle->threads, (void*)lthread);

	return 1;
}

void sniffer_thread_close (struct sniffer_thread_t* lthread) {
	if (lthread->devname != NULL) free(lthread->devname);
	if (lthread->pcap_hd != NULL) pcap_close(lthread->pcap_hd);
#ifdef BSDSOCKET
	if (lthread->pcap_fd != 0)    close(lthread->pcap_fd);
#elif WINSOCKET
	CloseHandle(lthread->w32event);
#endif
	//TODO:!!!
	//if (lthread->lock != 0)       pthread_mutex_destroy(&lthread->lock);
}

/** \brief Start to capture datagrams.
 *
 *  Start a thread that will capture all packets from the socket defined in
 *  <i>listen</i>.
 *
 *  @param listen   Handler of a raw socket.
 *  @param callback Callback function that will received all datagrams captured.
 */
void* sniffer_thread_run (void* params) {
        struct sniffer_thread_t* lthread = (struct sniffer_thread_t*)params;

#ifdef BSDSOCKET
        fd_set sfd;
	struct timeval tv;
	tv.tv_sec  = 0;
	tv.tv_usec = 5000;
#endif

        pthread_mutex_lock(&(lthread->lock));
        while (lthread->thread_running) {
                pthread_mutex_unlock(&lthread->lock);
#ifdef BSDSOCKET
        	FD_ZERO(&sfd);
	        FD_SET(lthread->pcap_fd, &sfd);
                int res = select(lthread->pcap_fd + 1, &sfd, NULL, NULL, &tv);
                if (res < 0) error("pcap: select failed");
                else if (res == 0) {}//warn("pcap: select timeout");
#elif WINSOCKET
		int res = WaitForSingleObject(lthread->w32event, 5000);
		if (res == WAIT_TIMEOUT) {}//warn("wpacap: event timeout");
#endif
		else { // Packet received
			debug("thread[%s]: packet received", lthread->devname);
	                struct pcap_pkthdr header;
        	        uint8* buff=(uint8*)pcap_next(lthread->pcap_hd,&header);
	                int buflen = header.len;

        	        if (buff == NULL) buflen = 0;

                	if (buflen > 0) {
	                        struct libnet_packet_t* packet;
        	                packet = malloc(sizeof(struct libnet_packet_t));
                	        packet->data        = buff;
                        	packet->length      = buflen;
				packet->offset      = lthread->datalink_length;
        	                //packet->timestamp   = header.ts;
				info("GAO");

                	        if (lthread->callback != NULL)
                        	    lthread->callback(packet,lthread->params);
	                }
			debug("thread[%s]: packet processed", lthread->devname);
		}
                pthread_mutex_lock(&(lthread->lock));
        }
        pthread_mutex_unlock(&(lthread->lock));

        return NULL;
}

